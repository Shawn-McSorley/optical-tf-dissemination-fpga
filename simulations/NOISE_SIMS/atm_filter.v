// -------------------------------------------------------------
//
// Module: atm_filter
// Generated by MATLAB(R) 9.11 and Filter Design HDL Coder 3.1.10.
// Generated on: 2022-12-13 11:54:15
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetDirectory: Z:\Uni\ICRAR_Internship\Phasemeter\Filters\hdlsrc
// AddPipelineRegisters: on
// Name: atm_filter
// TargetLanguage: Verilog
// TestBenchName: atm_filter_tb
// TestBenchStimulus: impulse step ramp chirp noise 

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form I, Second-Order Sections
// Number of Sections  : 3
// Stable              : No
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s32,29 -> [-4 4)
// Denominator         : s32,29 -> [-4 4)
// Scale Values        : s32,35 -> [-6.250000e-02 6.250000e-02)
// Input               : s32,0 -> [-2147483648 2147483648)
// Output              : s32,26 -> [-32 32)
// Numerator State     : s16,15 -> [-1 1)
// Denominator State   : s16,15 -> [-1 1)
// Numerator Prod      : s48,44 -> [-8 8)
// Denominator Prod    : s48,44 -> [-8 8)
// Numerator Accum     : s40,34 -> [-32 32)
// Denominator Accum   : s40,34 -> [-32 32)
// Round Mode          : convergent
// Overflow Mode       : wrap
// Cast Before Sum     : true
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module atm_filter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [31:0] filter_in; //sfix32
  output  signed [31:0] filter_out; //sfix32_En26

////////////////////////////////////////////////////////////////
//Module Architecture: atm_filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [31:0] scaleconst1 = 32'h66666710; //sfix32_En35
  parameter signed [31:0] coeff_b1_section1 = 32'h20000000; //sfix32_En29
  parameter signed [31:0] coeff_b2_section1 = 32'hBFF06459; //sfix32_En29
  parameter signed [31:0] coeff_b3_section1 = 32'h1FF24208; //sfix32_En29
  parameter signed [31:0] coeff_a2_section1 = 32'hBFCF935E; //sfix32_En29
  parameter signed [31:0] coeff_a3_section1 = 32'h2030851F; //sfix32_En29
  parameter signed [31:0] coeff_b1_section2 = 32'h20000000; //sfix32_En29
  parameter signed [31:0] coeff_b2_section2 = 32'hBE1A8955; //sfix32_En29
  parameter signed [31:0] coeff_b3_section2 = 32'h22037A5E; //sfix32_En29
  parameter signed [31:0] coeff_a2_section2 = 32'hC0302C34; //sfix32_En29
  parameter signed [31:0] coeff_a3_section2 = 32'h1FCFEBE8; //sfix32_En29
  parameter signed [31:0] coeff_b1_section3 = 32'h20000000; //sfix32_En29
  parameter signed [31:0] coeff_b2_section3 = 32'hC1F512CA; //sfix32_En29
  parameter signed [31:0] coeff_b3_section3 = 32'h1E27FCA7; //sfix32_En29
  parameter signed [31:0] coeff_a2_section3 = 32'hC000406E; //sfix32_En29
  parameter signed [31:0] coeff_a3_section3 = 32'h1FFFD7DF; //sfix32_En29
  // Signals
  reg  signed [31:0] input_register; // sfix32
  wire signed [78:0] scale1; // sfix79_En50
  wire signed [63:0] mul_temp; // sfix64_En35
  // Section 1 Signals 
  wire signed [15:0] numtypeconvert1; // sfix16_En15
  wire signed [39:0] a1sum1; // sfix40_En34
  wire signed [15:0] dentypeconvert1; // sfix16_En15
  reg  signed [15:0] numdelay_section1 [0:1] ; // sfix16_En15
  reg  signed [15:0] dendelay_section1 [0:1] ; // sfix16_En15
  wire signed [47:0] a2mul1; // sfix48_En44
  wire signed [47:0] a3mul1; // sfix48_En44
  wire signed [47:0] b1mul1; // sfix48_En44
  wire signed [47:0] b2mul1; // sfix48_En44
  wire signed [47:0] b3mul1; // sfix48_En44
  wire signed [39:0] b1sum1; // sfix40_En34
  wire signed [39:0] b2sum1; // sfix40_En34
  wire signed [39:0] b1multypeconvert1; // sfix40_En34
  wire signed [39:0] add_cast; // sfix40_En34
  wire signed [39:0] add_cast_1; // sfix40_En34
  wire signed [40:0] add_temp; // sfix41_En34
  wire signed [39:0] add_cast_2; // sfix40_En34
  wire signed [39:0] add_cast_3; // sfix40_En34
  wire signed [40:0] add_temp_1; // sfix41_En34
  wire signed [39:0] a2sum1; // sfix40_En34
  wire signed [39:0] sub_cast; // sfix40_En34
  wire signed [39:0] sub_cast_1; // sfix40_En34
  wire signed [40:0] sub_temp; // sfix41_En34
  wire signed [39:0] sub_cast_2; // sfix40_En34
  wire signed [39:0] sub_cast_3; // sfix40_En34
  wire signed [40:0] sub_temp_1; // sfix41_En34
  reg  signed [15:0] sos_pipeline1; // sfix16_En15
  // Section 2 Signals 
  wire signed [15:0] numtypeconvert2; // sfix16_En15
  wire signed [39:0] a1sum2; // sfix40_En34
  wire signed [15:0] dentypeconvert2; // sfix16_En15
  reg  signed [15:0] numdelay_section2 [0:1] ; // sfix16_En15
  reg  signed [15:0] dendelay_section2 [0:1] ; // sfix16_En15
  wire signed [47:0] a2mul2; // sfix48_En44
  wire signed [47:0] a3mul2; // sfix48_En44
  wire signed [47:0] b1mul2; // sfix48_En44
  wire signed [47:0] b2mul2; // sfix48_En44
  wire signed [47:0] b3mul2; // sfix48_En44
  wire signed [39:0] b1sum2; // sfix40_En34
  wire signed [39:0] b2sum2; // sfix40_En34
  wire signed [39:0] b1multypeconvert2; // sfix40_En34
  wire signed [39:0] add_cast_4; // sfix40_En34
  wire signed [39:0] add_cast_5; // sfix40_En34
  wire signed [40:0] add_temp_2; // sfix41_En34
  wire signed [39:0] add_cast_6; // sfix40_En34
  wire signed [39:0] add_cast_7; // sfix40_En34
  wire signed [40:0] add_temp_3; // sfix41_En34
  wire signed [39:0] a2sum2; // sfix40_En34
  wire signed [39:0] sub_cast_4; // sfix40_En34
  wire signed [39:0] sub_cast_5; // sfix40_En34
  wire signed [40:0] sub_temp_2; // sfix41_En34
  wire signed [39:0] sub_cast_6; // sfix40_En34
  wire signed [39:0] sub_cast_7; // sfix40_En34
  wire signed [40:0] sub_temp_3; // sfix41_En34
  reg  signed [15:0] sos_pipeline2; // sfix16_En15
  // Section 3 Signals 
  wire signed [15:0] numtypeconvert3; // sfix16_En15
  wire signed [39:0] a1sum3; // sfix40_En34
  wire signed [15:0] dentypeconvert3; // sfix16_En15
  reg  signed [15:0] numdelay_section3 [0:1] ; // sfix16_En15
  reg  signed [15:0] dendelay_section3 [0:1] ; // sfix16_En15
  wire signed [47:0] a2mul3; // sfix48_En44
  wire signed [47:0] a3mul3; // sfix48_En44
  wire signed [47:0] b1mul3; // sfix48_En44
  wire signed [47:0] b2mul3; // sfix48_En44
  wire signed [47:0] b3mul3; // sfix48_En44
  wire signed [39:0] b1sum3; // sfix40_En34
  wire signed [39:0] b2sum3; // sfix40_En34
  wire signed [39:0] b1multypeconvert3; // sfix40_En34
  wire signed [39:0] add_cast_8; // sfix40_En34
  wire signed [39:0] add_cast_9; // sfix40_En34
  wire signed [40:0] add_temp_4; // sfix41_En34
  wire signed [39:0] add_cast_10; // sfix40_En34
  wire signed [39:0] add_cast_11; // sfix40_En34
  wire signed [40:0] add_temp_5; // sfix41_En34
  wire signed [39:0] a2sum3; // sfix40_En34
  wire signed [39:0] sub_cast_8; // sfix40_En34
  wire signed [39:0] sub_cast_9; // sfix40_En34
  wire signed [40:0] sub_temp_4; // sfix41_En34
  wire signed [39:0] sub_cast_10; // sfix40_En34
  wire signed [39:0] sub_cast_11; // sfix40_En34
  wire signed [40:0] sub_temp_5; // sfix41_En34
  wire signed [31:0] output_typeconvert; // sfix32_En26
  reg  signed [31:0] output_register; // sfix32_En26

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  assign mul_temp = input_register * scaleconst1;
  assign scale1 = $signed({mul_temp[63:0], 15'b000000000000000});

  // ------------------ Section 1 ------------------

  assign numtypeconvert1 = (scale1[50:0] + {scale1[35], {34{~scale1[35]}}})>>>35;

  assign dentypeconvert1 = (a1sum1[34:0] + {a1sum1[19], {18{~a1sum1[19]}}})>>>19;

  always @ (posedge clk or posedge reset)
    begin: numdelay_process_section1
      if (reset == 1'b1) begin
        numdelay_section1[0] <= 16'b0000000000000000;
        numdelay_section1[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          numdelay_section1[1] <= numdelay_section1[0];
          numdelay_section1[0] <= numtypeconvert1;
        end
      end
    end // numdelay_process_section1

  always @ (posedge clk or posedge reset)
    begin: dendelay_process_section1
      if (reset == 1'b1) begin
        dendelay_section1[0] <= 16'b0000000000000000;
        dendelay_section1[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          dendelay_section1[1] <= dendelay_section1[0];
          dendelay_section1[0] <= dentypeconvert1;
        end
      end
    end // dendelay_process_section1

  assign a2mul1 = dendelay_section1[0] * coeff_a2_section1;

  assign a3mul1 = dendelay_section1[1] * coeff_a3_section1;

  assign b1mul1 = $signed({numtypeconvert1[15:0], 29'b00000000000000000000000000000});

  assign b2mul1 = numdelay_section1[0] * coeff_b2_section1;

  assign b3mul1 = numdelay_section1[1] * coeff_b3_section1;

  assign b1multypeconvert1 = ({{2{b1mul1[47]}}, b1mul1[47:0]} + {b1mul1[10], {9{~b1mul1[10]}}})>>>10;

  assign add_cast = b1multypeconvert1;
  assign add_cast_1 = ({{2{b2mul1[47]}}, b2mul1[47:0]} + {b2mul1[10], {9{~b2mul1[10]}}})>>>10;
  assign add_temp = add_cast + add_cast_1;
  assign b1sum1 = add_temp[39:0];

  assign add_cast_2 = b1sum1;
  assign add_cast_3 = ({{2{b3mul1[47]}}, b3mul1[47:0]} + {b3mul1[10], {9{~b3mul1[10]}}})>>>10;
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign b2sum1 = add_temp_1[39:0];

  assign sub_cast = b2sum1;
  assign sub_cast_1 = ({{2{a2mul1[47]}}, a2mul1[47:0]} + {a2mul1[10], {9{~a2mul1[10]}}})>>>10;
  assign sub_temp = sub_cast - sub_cast_1;
  assign a2sum1 = sub_temp[39:0];

  assign sub_cast_2 = a2sum1;
  assign sub_cast_3 = ({{2{a3mul1[47]}}, a3mul1[47:0]} + {a3mul1[10], {9{~a3mul1[10]}}})>>>10;
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign a1sum1 = sub_temp_1[39:0];

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section1
      if (reset == 1'b1) begin
        sos_pipeline1 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline1 <= dentypeconvert1;
        end
      end
    end // sos_pipeline_process_section1

  // ------------------ Section 2 ------------------

  assign numtypeconvert2 = sos_pipeline1;

  assign dentypeconvert2 = (a1sum2[34:0] + {a1sum2[19], {18{~a1sum2[19]}}})>>>19;

  always @ (posedge clk or posedge reset)
    begin: numdelay_process_section2
      if (reset == 1'b1) begin
        numdelay_section2[0] <= 16'b0000000000000000;
        numdelay_section2[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          numdelay_section2[1] <= numdelay_section2[0];
          numdelay_section2[0] <= numtypeconvert2;
        end
      end
    end // numdelay_process_section2

  always @ (posedge clk or posedge reset)
    begin: dendelay_process_section2
      if (reset == 1'b1) begin
        dendelay_section2[0] <= 16'b0000000000000000;
        dendelay_section2[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          dendelay_section2[1] <= dendelay_section2[0];
          dendelay_section2[0] <= dentypeconvert2;
        end
      end
    end // dendelay_process_section2

  assign a2mul2 = dendelay_section2[0] * coeff_a2_section2;

  assign a3mul2 = dendelay_section2[1] * coeff_a3_section2;

  assign b1mul2 = $signed({numtypeconvert2[15:0], 29'b00000000000000000000000000000});

  assign b2mul2 = numdelay_section2[0] * coeff_b2_section2;

  assign b3mul2 = numdelay_section2[1] * coeff_b3_section2;

  assign b1multypeconvert2 = ({{2{b1mul2[47]}}, b1mul2[47:0]} + {b1mul2[10], {9{~b1mul2[10]}}})>>>10;

  assign add_cast_4 = b1multypeconvert2;
  assign add_cast_5 = ({{2{b2mul2[47]}}, b2mul2[47:0]} + {b2mul2[10], {9{~b2mul2[10]}}})>>>10;
  assign add_temp_2 = add_cast_4 + add_cast_5;
  assign b1sum2 = add_temp_2[39:0];

  assign add_cast_6 = b1sum2;
  assign add_cast_7 = ({{2{b3mul2[47]}}, b3mul2[47:0]} + {b3mul2[10], {9{~b3mul2[10]}}})>>>10;
  assign add_temp_3 = add_cast_6 + add_cast_7;
  assign b2sum2 = add_temp_3[39:0];

  assign sub_cast_4 = b2sum2;
  assign sub_cast_5 = ({{2{a2mul2[47]}}, a2mul2[47:0]} + {a2mul2[10], {9{~a2mul2[10]}}})>>>10;
  assign sub_temp_2 = sub_cast_4 - sub_cast_5;
  assign a2sum2 = sub_temp_2[39:0];

  assign sub_cast_6 = a2sum2;
  assign sub_cast_7 = ({{2{a3mul2[47]}}, a3mul2[47:0]} + {a3mul2[10], {9{~a3mul2[10]}}})>>>10;
  assign sub_temp_3 = sub_cast_6 - sub_cast_7;
  assign a1sum2 = sub_temp_3[39:0];

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section2
      if (reset == 1'b1) begin
        sos_pipeline2 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline2 <= dentypeconvert2;
        end
      end
    end // sos_pipeline_process_section2

  // ------------------ Section 3 ------------------

  assign numtypeconvert3 = sos_pipeline2;

  assign dentypeconvert3 = (a1sum3[34:0] + {a1sum3[19], {18{~a1sum3[19]}}})>>>19;

  always @ (posedge clk or posedge reset)
    begin: numdelay_process_section3
      if (reset == 1'b1) begin
        numdelay_section3[0] <= 16'b0000000000000000;
        numdelay_section3[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          numdelay_section3[1] <= numdelay_section3[0];
          numdelay_section3[0] <= numtypeconvert3;
        end
      end
    end // numdelay_process_section3

  always @ (posedge clk or posedge reset)
    begin: dendelay_process_section3
      if (reset == 1'b1) begin
        dendelay_section3[0] <= 16'b0000000000000000;
        dendelay_section3[1] <= 16'b0000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          dendelay_section3[1] <= dendelay_section3[0];
          dendelay_section3[0] <= dentypeconvert3;
        end
      end
    end // dendelay_process_section3

  assign a2mul3 = dendelay_section3[0] * coeff_a2_section3;

  assign a3mul3 = dendelay_section3[1] * coeff_a3_section3;

  assign b1mul3 = $signed({numtypeconvert3[15:0], 29'b00000000000000000000000000000});

  assign b2mul3 = numdelay_section3[0] * coeff_b2_section3;

  assign b3mul3 = numdelay_section3[1] * coeff_b3_section3;

  assign b1multypeconvert3 = ({{2{b1mul3[47]}}, b1mul3[47:0]} + {b1mul3[10], {9{~b1mul3[10]}}})>>>10;

  assign add_cast_8 = b1multypeconvert3;
  assign add_cast_9 = ({{2{b2mul3[47]}}, b2mul3[47:0]} + {b2mul3[10], {9{~b2mul3[10]}}})>>>10;
  assign add_temp_4 = add_cast_8 + add_cast_9;
  assign b1sum3 = add_temp_4[39:0];

  assign add_cast_10 = b1sum3;
  assign add_cast_11 = ({{2{b3mul3[47]}}, b3mul3[47:0]} + {b3mul3[10], {9{~b3mul3[10]}}})>>>10;
  assign add_temp_5 = add_cast_10 + add_cast_11;
  assign b2sum3 = add_temp_5[39:0];

  assign sub_cast_8 = b2sum3;
  assign sub_cast_9 = ({{2{a2mul3[47]}}, a2mul3[47:0]} + {a2mul3[10], {9{~a2mul3[10]}}})>>>10;
  assign sub_temp_4 = sub_cast_8 - sub_cast_9;
  assign a2sum3 = sub_temp_4[39:0];

  assign sub_cast_10 = a2sum3;
  assign sub_cast_11 = ({{2{a3mul3[47]}}, a3mul3[47:0]} + {a3mul3[10], {9{~a3mul3[10]}}})>>>10;
  assign sub_temp_5 = sub_cast_10 - sub_cast_11;
  assign a1sum3 = sub_temp_5[39:0];

  assign output_typeconvert = $signed({dentypeconvert3[15:0], 11'b00000000000});

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // atm_filter
