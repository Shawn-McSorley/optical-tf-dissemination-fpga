// -------------------------------------------------------------
//
// Module: CIC_R16_N2_DEC
// Generated by MATLAB(R) 9.11 and Filter Design HDL Coder 3.1.10.
// Generated on: 2022-12-12 19:16:53
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// AddInputRegister: off
// AddOutputRegister: off
// AddPipelineRegisters: on
// Name: CIC_R16_N2_DEC
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp noise 
// GenerateHDLTestBench: off

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure        : Cascaded Integrator-Comb Decimator
// Decimation Factor       : 16
// Differential Delay      : 1
// Number of Sections      : 2
// Stable                  : Yes
// Linear Phase            : Yes (Type 1)
//
// Input                   : s14,0
// Output                  : s14,-8
// Filter Internals        : Specified Word Lengths
//   Integrator Section 1  : s24,2
//   Integrator Section 2  : s24,2
//   Comb Section 1        : s24,2
//   Comb Section 2        : s24,2
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module CIC_R16_N2_DEC
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [13:0] filter_in; //sfix14
  output  signed [13:0] filter_out; //sfix14_E8
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: CIC_R16_N2_DEC
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  // Signals
  wire signed [13:0] input_typeconvert; // sfix14
  reg  [3:0] cur_count; // ufix4
  wire phase_0; // boolean
  reg ce_delayline; // boolean
  wire ce_gated; // boolean
  //   -- Section 1 Signals 
  wire signed [13:0] section_in1; // sfix14
  wire signed [23:0] section_cast1; // sfix24_En2
  wire signed [23:0] sum1; // sfix24_En2
  reg  signed [23:0] section_out1; // sfix24_En2
  wire signed [23:0] add_cast; // sfix24_En2
  wire signed [23:0] add_cast_1; // sfix24_En2
  wire signed [24:0] add_temp; // sfix25_En2
  //   -- Section 2 Signals 
  wire signed [23:0] section_in2; // sfix24_En2
  wire signed [23:0] sum2; // sfix24_En2
  reg  signed [23:0] section_out2; // sfix24_En2
  wire signed [23:0] add_cast_2; // sfix24_En2
  wire signed [23:0] add_cast_3; // sfix24_En2
  wire signed [24:0] add_temp_1; // sfix25_En2
  //   -- Section 3 Signals 
  wire signed [23:0] section_in3; // sfix24_En2
  reg  signed [23:0] diff1; // sfix24_En2
  wire signed [23:0] section_out3; // sfix24_En2
  wire signed [23:0] sub_cast; // sfix24_En2
  wire signed [23:0] sub_cast_1; // sfix24_En2
  wire signed [24:0] sub_temp; // sfix25_En2
  reg  signed [23:0] cic_pipeline3; // sfix24_En2
  //   -- Section 4 Signals 
  wire signed [23:0] section_in4; // sfix24_En2
  reg  signed [23:0] diff2; // sfix24_En2
  wire signed [23:0] section_out4; // sfix24_En2
  wire signed [23:0] sub_cast_2; // sfix24_En2
  wire signed [23:0] sub_cast_3; // sfix24_En2
  wire signed [24:0] sub_temp_1; // sfix25_En2
  wire signed [13:0] output_typeconvert; // sfix14_E8
  reg  signed [13:0] regout; // sfix14_E8
  wire signed [13:0] muxout; // sfix14_E8

  // Block Statements
  //   ------------------ CE Output Generation ------------------

  always @ (posedge clk or posedge reset)
    begin: ce_output
      if (reset == 1'b1) begin
        cur_count <= 4'b0000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          if (cur_count >= 4'b1111) begin
            cur_count <= 4'b0000;
          end
          else begin
            cur_count <= cur_count + 4'b0001;
          end
        end
      end
    end // ce_output

  assign  phase_0 = (cur_count == 4'b0000 && clk_enable == 1'b1) ? 1'b1 : 1'b0;

  always @ (posedge clk or posedge reset)
    begin: ce_delay
      if (reset == 1'b1) begin
        ce_delayline <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          ce_delayline <= clk_enable;
        end
      end
    end // ce_delay
  assign ce_gated =  ce_delayline & phase_0;

  assign input_typeconvert = filter_in;

  //   ------------------ Section # 1 : Integrator ------------------

  assign section_in1 = input_typeconvert;

  assign section_cast1 = $signed({section_in1[13:0], 2'b00});

  assign add_cast = section_cast1;
  assign add_cast_1 = section_out1;
  assign add_temp = add_cast + add_cast_1;
  assign sum1 = add_temp[23:0];

  always @ (posedge clk or posedge reset)
    begin: integrator_delay_section1
      if (reset == 1'b1) begin
        section_out1 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          section_out1 <= sum1;
        end
      end
    end // integrator_delay_section1

  //   ------------------ Section # 2 : Integrator ------------------

  assign section_in2 = section_out1;

  assign add_cast_2 = section_in2;
  assign add_cast_3 = section_out2;
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign sum2 = add_temp_1[23:0];

  always @ (posedge clk or posedge reset)
    begin: integrator_delay_section2
      if (reset == 1'b1) begin
        section_out2 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          section_out2 <= sum2;
        end
      end
    end // integrator_delay_section2

  //   ------------------ Section # 3 : Comb ------------------

  assign section_in3 = section_out2;

  assign sub_cast = section_in3;
  assign sub_cast_1 = diff1;
  assign sub_temp = sub_cast - sub_cast_1;
  assign section_out3 = sub_temp[23:0];

  always @ (posedge clk or posedge reset)
    begin: comb_delay_section3
      if (reset == 1'b1) begin
        diff1 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          diff1 <= section_in3;
        end
      end
    end // comb_delay_section3

  always @ (posedge clk or posedge reset)
    begin: cic_pipeline_process_section3
      if (reset == 1'b1) begin
        cic_pipeline3 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          cic_pipeline3 <= section_out3;
        end
      end
    end // cic_pipeline_process_section3

  //   ------------------ Section # 4 : Comb ------------------

  assign section_in4 = cic_pipeline3;

  assign sub_cast_2 = section_in4;
  assign sub_cast_3 = diff2;
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign section_out4 = sub_temp_1[23:0];

  always @ (posedge clk or posedge reset)
    begin: comb_delay_section4
      if (reset == 1'b1) begin
        diff2 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          diff2 <= section_in4;
        end
      end
    end // comb_delay_section4

  assign output_typeconvert = section_out4[23:10];

  always @ (posedge clk or posedge reset)
    begin: DataHoldRegister_process
      if (reset == 1'b1) begin
        regout <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          regout <= output_typeconvert;
        end
      end
    end // DataHoldRegister_process

  assign muxout = (phase_0 == 1'b1) ? output_typeconvert :
            regout;
  // Assignment Statements
  assign ce_out = ce_gated;
  assign filter_out = muxout;
endmodule  // CIC_R16_N2_DEC
